'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var fs = require('fs');
var joinPath = require('path').join;
var flatten = require('tree-flatten');
var Mode = require('./mode');

function _readDir(dir) {
  return new Promise(function (resolve, reject) {
    fs.readdir(dir, function (err, files) {
      if (err) {
        reject(err);
      } else {
        var filesInfo = files.map(function (file) {
          var filePath = joinPath(dir, file);

          return {
            path: filePath,
            mode: new Mode(fs.statSync(filePath).mode),
            files: []
          };
        });

        resolve({
          path: joinPath(dir),
          mode: new Mode(fs.statSync(dir).mode),
          files: filesInfo
        });
      }
    });
  });
}

function _listFiles(path, options) {
  var recurse = !!options.recurse;
  return _readDir(path).then(function (file) {
    if (!recurse) {
      return file;
    }

    var files = file.files.map(function (innerFile) {
      if (!innerFile.mode.dir) {
        return Promise.resolve(innerFile);
      }

      return _listFiles(innerFile.path, options);
    });

    return Promise.all(files).then(function (files) {
      var mode = file.mode;
      var path = file.path;
      return {
        path: path,
        mode: mode,
        files: files
      };
    });
  });
}

function list(paths, options) {
  var opts = _extends({}, options);
  var promises = paths.map(function (path) {
    return _listFiles(path, opts);
  });
  return Promise.all(promises).then(function (files) {
    if (opts.flatten) {
      return files.map(function (root) {
        return flatten(root, 'files');
      }).reduce(function (a, b) {
        return a.concat(b);
      }, []);
    }

    return files;
  });
}

module.exports = list;